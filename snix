#!/usr/bin/env python

import argparse
import shlex
import os
import subprocess

from command import Command
from snixContext import snixContext
from snixCore import abort

from snixLogger import SnixLogger

logger = SnixLogger.logger()


class Snix:
    """The Actual Snix CLI command. Type snix --help for more information"""

    def __init__(self):
        self._cliParser = argparse.ArgumentParser()
        self._configure_parser()

    # TODO: shouldn't have to call this everytime.
    # TODO : how do I document each action
    def _configure_parser(self):
        self._cliParser.add_argument("action", choices=['init', 'test', 'run'], help="An action that snix can perform.")
        self._cliParser.add_argument("argument", help="Additional argument for a specified action", nargs='?')

    def go(self):
        args = self._cliParser.parse_args()
        action = {
            "init": self.init,
            "test": self.test,
            "run": self.run,
        }.get(args.action)
        if args.argument:
            self._perform(action, args.argument)
        else:
            self._perform(action)

    def _perform(self, action, *args):
        logger.info("`snix {0}` with args: {1}".format(action.__name__, args))
        action(*args)

    #TODO generate keys and upload to github.
    def _configure_git(self,email):
        msg = "Configuring git..."

        try:
            subprocess.check_call(
                ['git', 'config', '--global', 'user.email', email], stdin=None, shell=False)
            output = subprocess.check_output(['git', 'config', '--get', 'user.email', email], stdin=None, shell=False)
            logger.info(msg + "Set global user email to:%s" % output)
        except subprocess.CalledProcessError as e:
            abort(msg + "{0} exited with error code{1}".format(e.cmd, e.returncode))
        logger.info(msg + 'Done!')


    #TODO this is currently mac specific. Also this might require root password.
    def _install_prerequisite_items(self):
        logger.info("Installing prerequisite items...")
        try:
            cmd = 'ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"'
            Command({'command': cmd, 'command_exec_dir': os.getcwd()},True).execute()
            Command({'command': shlex.split("brew tap caskroom/cask"), 'command_exec_dir': os.getcwd()}).execute()
            Command({'command': shlex.split("brew install python"), 'command_exec_dir': os.getcwd()}).execute()
            Command({'command': shlex.split("pip install jsonschema"), 'command_exec_dir': os.getcwd()}).execute()
        except subprocess.CalledProcessError as e:
            abort("{0} exited with error code{1}".format(e.cmd, e.returncode))




        #

        # self.__createDir(self.manifest.getConfigurationValue("workingDir"))
        # self.__createDir(self.manifest.getConfigurationValue("rcDir"))
        # self.manifest.getItem("homebrew").install()

    # def __createDir(self, path):
    #     dir = os.path.dirname(path)
    #     if not os.path.exists(dir):
    #         logger.info("Creating %s." % dir)
    #         os.makedirs(dir)
    #     else:
    #         logger.info("%s already exists." % dir)

    def _execute(self, manifest_file, test):
        snix_context = snixContext.construct_from(manifest_file)
        #parse and validate manifest. parse and validate all includes recursively
        #Build an execution snix_context.
        # 1 Install s/w
        # 2 Clone repos
        # 3 Run customizations
        if test:
            logger.info('Test Run Requested. Here\'s what will be executed. ')
            logger.info(snix_context)
        else:
            self._install_items(snix_context)
            self._clone_repos(snix_context)
            self._execute_custom_scripts(snix_context)
            logger.info("-------->>and we're done! Happy Coding!")

    def _install_items(self, context):
        for item in context.get_items():
            item.install()

    def _clone_repos(self, context):
        for repo in context.get_repos():
            repo.clone()

    def _execute_custom_scripts(self, context):
        for script in context.get_custom_scripts():
            script.execute()

    def test(self, manifest_file):
        """Parse the manifest, Validate it and show what you'll do i.e. dry run only"""
        return self._execute(manifest_file, True)

    def run(self, manifest_file):
        """Parse the manifest, Validate it and execute the manifest"""
        return self._execute(manifest_file, False)

    def init(self):
        """Initializes snix. Sets up the required directories and tools required for Snix to work."""
        self._install_prerequisite_items()

        email = raw_input('Please enter your email address:')
        self._configure_git(email)
        # intialize git. conigure user name . configure email


if __name__ == "__main__":
    cliParser = argparse.ArgumentParser()
    cliParser.add_argument("action", choices=['init', 'test', 'run'], help="An action that snix can perform.")
    cliParser.add_argument("argument", help="Additional argument for a specified action", nargs='?')

# TODO: shouldn't have to call this everytime.
# TODO : how do I document each action
    snix = Snix()
    snix.go()

# TODO tab completion.
# TODO brew installer isn't dumping warning output.
# TODO clean up the warnings.
# TODO init should complain if bootstrap hasn't already run.
# TODO complain if commands that take an argument don't get one. Right now it just fails.
    # TODO: extract all the subprocess stuff into a method. - > move to snix.py
    # TODO: validate email address. -> move to snix.py